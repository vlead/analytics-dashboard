
#+TITLE: Analytics-Dashboard
#+AUTHOR: VLEAD
#+DATE: [2017-05-12 Fri]
#+SETUPFILE: ../../org-templates/level-2.org
#+TAGS: boilerplate(b)
#+EXCLUDE_TAGS: boilerplate
#+OPTIONS: ^:nil

* Introduction
  :PROPERTIES:
  :CUSTOM_ID: introduction
  :END: 
  This "literate mode" displays the visualization of the feedbacks given by the users.
* WebApp
** Structure of html
#+NAME: main-html
#+BEGIN_SRC html 
<!DOCTYPE html>
<html>
<head>
<title>Dashboard</title>
<link rel="stylesheet" href="../static/css/tab.css" />
</head>
<body>
<div class = "main">
<div id='dashboard' class="bottom">
  <div id="fillgaugeContainer">
  <svg id="fillgauge1" width="100%" height="240"></svg>
</div>
</div>
</div>
<script src="https://d3js.org/d3.v3.min.js"></script>
<script src="https://code.jquery.com/jquery-3.2.1.min.js"></script>
<script src="../static/js/chart_display.js"></script>
</body>
</html>
#+END_SRC

** Liquid Fill Gauge Default Settings
   Following function contain liquid fill gauge default settings
#+NAME: liquidfillgauge-defaultsettings
#+BEGIN_SRC html 

    var count = 0;
$.ajax({ // Ajax call for URL
  method: 'GET',
  url: "http://feedback-analytics.vlabs.ac.in/vlabs/feedback/_count", // Keep URL here
  type: 'json' // define type here
}).done(function(data /*this is the data or response*/ ) {
  
      
  var data = data;
  
  count = data.count;
  loadLiquidFillGauge("fillgauge1", count)

});

function liquidFillGaugeDefaultSettings() {
  return {
    minValue: 0, // The gauge minimum value.
    maxValue: 10000, // The gauge maximum value.
    circleThickness: 0.05, // The outer circle thickness as a percentage of it's radius.
    circleFillGap: 0.05, // The size of the gap between the outer circle and wave circle as a percentage of the outer circles radius.
    circleColor: "#178BCA", // The color of the outer circle.
    waveHeight: 0.05, // The wave height as a percentage of the radius of the wave circle.
    waveCount: 3, // The number of full waves per width of the wave circle.
    waveRiseTime: 1000, // The amount of time in milliseconds for the wave to rise from 0 to it's final height.
    waveAnimateTime: 1000, // The amount of time in milliseconds for a full wave to enter the wave circle.
    waveRise: true, // Control if the wave should rise from 0 to it's full height, or start at it's full height.
    waveHeightScaling: true, // Controls wave size scaling at low and high fill percentages. When true, wave height reaches it's maximum at 50% fill, and minimum at 0% and 100% fill. This helps to prevent the wave from making the wave circle from appear totally full or empty when near it's minimum or maximum fill.
    waveAnimate: true, // Controls if the wave scrolls or is static.
    waveColor: "#178BCA", // The color of the fill wave.
    waveOffset: 0.25, // The amount to initially offset the wave. 0 = no offset. 1 = offset of one full wave.
    textVertPosition: .8, // The height at which to display the percentage text withing the wave circle. 0 = bottom, 1 = top.
    textSize: 0.6, // The relative height of the text to display in the wave circle. 1 = 50%
    valueCountUp: true, // If true, the displayed value counts up from 0 to it's final value upon loading. If false, the final value is displayed.
    displayPercent: false, // If true, a % symbol is displayed after the value.
    textColor: "#045681", // The color of the value text when the wave does not overlap it.
    waveTextColor: "#A4DBf8" // The color of the value text when the wave overlaps it.
  };
}
#+END_SRC

** Load Liquid Fill Gauge
   Following function calls when liquid fill gauge function gets load
#+NAME: load-liquidfillgauge
#+BEGIN_SRC html 
function loadLiquidFillGauge(elementId, value, config) {
  if (config == null) config = liquidFillGaugeDefaultSettings();

  var gauge = d3.select("#" + elementId);
  var radius = Math.min(parseInt(gauge.style("width")), parseInt(gauge.style("height"))) / 2;
  var locationX = parseInt(gauge.style("width")) / 2 - radius;
  var locationY = parseInt(gauge.style("height")) / 2 - radius;
  var fillPercent = Math.max(config.minValue, Math.min(config.maxValue, value)) / config.maxValue;

  var waveHeightScale;
  if (config.waveHeightScaling) {
    waveHeightScale = d3.scale.linear()
      .range([0, config.waveHeight, 0])
      .domain([0, 50, 100]);
  } else {
    waveHeightScale = d3.scale.linear()
      .range([config.waveHeight, config.waveHeight])
      .domain([0, 100]);
  }

  var textPixels = (config.textSize * radius / 2);
  var textFinalValue = parseFloat(value).toFixed(2);
  var textStartValue = config.valueCountUp ? config.minValue : textFinalValue;
  var percentText = config.displayPercent ? "%" : "";
  var circleThickness = config.circleThickness * radius;
  var circleFillGap = config.circleFillGap * radius;
  var fillCircleMargin = circleThickness + circleFillGap;
  var fillCircleRadius = radius - fillCircleMargin;
  var waveHeight = fillCircleRadius * waveHeightScale(fillPercent * 100);

  var waveLength = fillCircleRadius * 2 / config.waveCount;
  var waveClipCount = 1 + config.waveCount;
  var waveClipWidth = waveLength * waveClipCount;

  // Rounding functions so that the correct number of decimal places is always displayed as the value counts up.
  var textRounder = function(value) {
    return Math.round(value);
  };
  if (parseFloat(textFinalValue) != parseFloat(textRounder(textFinalValue))) {
    textRounder = function(value) {
      return parseFloat(value).toFixed(1);
    };
  }
  if (parseFloat(textFinalValue) != parseFloat(textRounder(textFinalValue))) {
    textRounder = function(value) {
      return parseFloat(value).toFixed(2);
    };
  }

  // Data for building the clip wave area.
  var data = [];
  for (var i = 0; i <= 40 * waveClipCount; i++) {
    data.push({
      x: i / (40 * waveClipCount),
      y: (i / (40))
    });
  }

  // Scales for drawing the outer circle.
  var gaugeCircleX = d3.scale.linear().range([0, 2 * Math.PI]).domain([0, 1]);
  var gaugeCircleY = d3.scale.linear().range([0, radius]).domain([0, radius]);

  // Scales for controlling the size of the clipping path.
  var waveScaleX = d3.scale.linear().range([0, waveClipWidth]).domain([0, 1]);
  var waveScaleY = d3.scale.linear().range([0, waveHeight]).domain([0, 1]);

  // Scales for controlling the position of the clipping path.
  var waveRiseScale = d3.scale.linear()
    // The clipping area size is the height of the fill circle + the wave height, so we position the clip wave
    // such that the it will won't overlap the fill circle at all when at 0%, and will totally cover the fill
    // circle at 100%.
    .range([(fillCircleMargin + fillCircleRadius * 2 + waveHeight), (fillCircleMargin - waveHeight)])
    .domain([0, 1]);
  var waveAnimateScale = d3.scale.linear()
    .range([0, waveClipWidth - fillCircleRadius * 2]) // Push the clip area one full wave then snap back.
    .domain([0, 1]);

  // Scale for controlling the position of the text within the gauge.
  var textRiseScaleY = d3.scale.linear()
    .range([fillCircleMargin + fillCircleRadius * 2, (fillCircleMargin + textPixels * 0.7)])
    .domain([0, 1]);

  // Center the gauge within the parent SVG.
  var gaugeGroup = gauge.append("g")
    .attr('transform', 'translate(' + locationX + ',' + locationY + ')');

  // Draw the outer circle.
  var gaugeCircleArc = d3.svg.arc()
    .startAngle(gaugeCircleX(0))
    .endAngle(gaugeCircleX(1))
    .outerRadius(gaugeCircleY(radius))
    .innerRadius(gaugeCircleY(radius - circleThickness));
  gaugeGroup.append("path")
    .attr("d", gaugeCircleArc)
    .style("fill", config.circleColor)
    .attr('transform', 'translate(' + radius + ',' + radius + ')');

  // Text where the wave does not overlap.
  var text1 = gaugeGroup.append("text")
    .text(textRounder(textStartValue) + percentText)
    .attr("class", "liquidFillGaugeText")
    .attr("text-anchor", "middle")
    .attr("font-size", textPixels + "px")
    .style("fill", config.textColor)
    .attr('transform', 'translate(' + radius + ',' + textRiseScaleY(config.textVertPosition) + ')');

  // The clipping wave area.
  var clipArea = d3.svg.area()
    .x(function(d) {
      return waveScaleX(d.x);
    })
    .y0(function(d) {
      return waveScaleY(Math.sin(Math.PI * 2 * config.waveOffset * -1 + Math.PI * 2 * (1 - config.waveCount) + d.y * 2 * Math.PI));
    })
    .y1(function(d) {
      return (fillCircleRadius * 2 + waveHeight);
    });
  var waveGroup = gaugeGroup.append("defs")
    .append("clipPath")
    .attr("id", "clipWave" + elementId);
  var wave = waveGroup.append("path")
    .datum(data)
    .attr("d", clipArea);

  // The inner circle with the clipping wave attached.
  var fillCircleGroup = gaugeGroup.append("g")
    .attr("clip-path", "url(#clipWave" + elementId + ")");
  fillCircleGroup.append("circle")
    .attr("cx", radius)
    .attr("cy", radius)
    .attr("r", fillCircleRadius)
    .style("fill", config.waveColor);

  // Text where the wave does overlap.
  var text2 = fillCircleGroup.append("text")
    .text(textRounder(textStartValue) + percentText)
    .attr("class", "liquidFillGaugeText")
    .attr("text-anchor", "middle")
    .attr("font-size", textPixels + "px")
    .style("fill", config.waveTextColor)
    .attr('transform', 'translate(' + radius + ',' + textRiseScaleY(config.textVertPosition) + ')');

  // Make the value count up.
  if (config.valueCountUp) {
    var textTween = function() {
      var i = d3.interpolate(this.textContent, textFinalValue);
      return function(t) {
        this.textContent = textRounder(i(t)) + percentText;
      }
    };
    text1.transition()
      .duration(config.waveRiseTime)
      .tween("text", textTween);
    text2.transition()
      .duration(config.waveRiseTime)
      .tween("text", textTween);
  }

  // Make the wave rise. wave and waveGroup are separate so that horizontal and vertical movement can be controlled independently.
  var waveGroupXPosition = fillCircleMargin + fillCircleRadius * 2 - waveClipWidth;
  if (config.waveRise) {
    waveGroup.attr('transform', 'translate(' + waveGroupXPosition + ',' + waveRiseScale(0) + ')')
      .transition()
      .duration(config.waveRiseTime)
      .attr('transform', 'translate(' + waveGroupXPosition + ',' + waveRiseScale(fillPercent) + ')')
      .each("start", function() {
        wave.attr('transform', 'translate(1,0)');
      }); // This transform is necessary to get the clip wave positioned correctly when waveRise=true and waveAnimate=false. The wave will not position correctly without this, but it's not clear why this is actually necessary.
  } else {
    waveGroup.attr('transform', 'translate(' + waveGroupXPosition + ',' + waveRiseScale(fillPercent) + ')');
  }

  if (config.waveAnimate) animateWave();

  function animateWave() {
    wave.transition()
      .duration(config.waveAnimateTime)
      .ease("linear")
      .attr('transform', 'translate(' + waveAnimateScale(1) + ',0)')
      .each("end", function() {
        wave.attr('transform', 'translate(' + waveAnimateScale(0) + ',0)');
        animateWave(config.waveAnimateTime);
      });
  }
}
#+END_SRC

** Dashboard
   It contains template of bar graph and two pie charts showing every detail of feedback counts filter by year, lab, experiments, generic.
#+NAME: main-dashboard
#+BEGIN_SRC html
function dashboard(id, fData) {
  var self =this;
  self.yearSelected=''
  var barColor = 'steelblue';

  function segColor(c) {
    console.log('c',c)
    return {
     experiment: "#cc4748",
      generic: "#cd82ad",            
      lab: "#84b761",
      generic_exp_feedback_v2_0: "#cd82ad",
      open_edx_virtual_labs_v2_0_for_experiment: "#cc4748",
      generic_lab_feedback_v2_0: "#84b761",
      generic_feedback_v2_0: '#cd65cc',
      open_edx_virtual_labs_v2_0_for_lab:'#aa65cc',
      virtual_labs_feedback_v1_0:'#ddaa00'
      }[c];
  }

  // compute total for each state.

  fData.forEach(function(d) {
    if (d.freq.experiment == 0 || !d.freq.experiment) {
      d.freq.experiment = 0
    }
    if (d.freq.generic == 0 || !d.freq.generic) {
      d.freq.generic = 0
    }    
    if (d.freq.lab == 0 || !d.freq.lab) {
      d.freq.lab = 0
    }
    if (d.freq.virtual_labs_feedback_v1_0 == 0 || !d.freq.virtual_labs_feedback_v1_0) {
      d.freq.virtual_labs_feedback_v1_0 = 0
    }
    if (d.freq.open_edx_virtual_labs_v2_0_for_lab == 0 || !d.freq.open_edx_virtual_labs_v2_0_for_lab) {
      d.freq.open_edx_virtual_labs_v2_0_for_lab = 0
    }
    if (d.freq.generic_feedback_v2_0 == 0 || !d.freq.generic_feedback_v2_0) {
      d.freq.generic_feedback_v2_0 = 0
    }
    
    if (d.freq.open_edx_virtual_labs_v2_0_for_experiment == 0 || !d.freq.open_edx_virtual_labs_v2_0_for_experiment) {
      d.freq.open_edx_virtual_labs_v2_0_for_experiment = 0
    }
    if (d.freq.generic_exp_feedback_v2_0 == 0 || !d.freq.generic_exp_feedback_v2_0) {
      d.freq.generic_exp_feedback_v2_0 = 0
    }
    if (d.freq.generic_lab_feedback_v2_0 == 0 || !d.freq.generic_lab_feedback_v2_0) {
      d.freq.generic_lab_feedback_v2_0 = 0
    }
    
 /*
r = str.replace(/virtual-labs-feedback-v1.0/g, 'virtual_labs_feedback_v1_0');
  str = str.replace(/open-edx-virtual-labs-v2.0_for_lab/g, 'open_edx_virtual_labs_v2_0_for_lab');
  str = str.replace(/generic-feedback-v2.0/g, 'generic_feedback_v2_0');
  str = str.replace(/open-edx-virtual-labs-v2.0_for_experiment/g, 'open_edx_virtual_labs_v2_0_for_experiment');
  str = str.replace(/generic-exp-feedback-v2.0/g, 'generic_exp_feedback_v2_0');
  str = str.replace(/generic-lab-feedback-v2.0/g, 'generic_lab_feedback_v2_0');

*/   
    d.total = parseInt(d.freq.generic + d.freq.experiment + d.freq.lab + d.freq.virtual_labs_feedback_v1_0 + d.freq.open_edx_virtual_labs_v2_0_for_lab + d.freq.generic_feedback_v2_0 + d.freq.open_edx_virtual_labs_v2_0_for_experiment + d.freq.generic_exp_feedback_v2_0 + d.freq.generic_lab_feedback_v2_0);

  });

  // function to handle histogram.
  function histoGram(fD) {
    var hG = {},
      hGDim = {
        t: 60,
        r: 0,
        b: 30,
        l: 0
      };
    hGDim.w = 300 - hGDim.l - hGDim.r,
      hGDim.h = 300 - hGDim.t - hGDim.b;

    //create svg for histogram.
    //$('div').attr('id','barChartExample').appendTo(id);
    $(id).append('<div id="barChartExample"></div>');
    var hGsvg = d3.select('#barChartExample').append("svg")
      .attr("width", hGDim.w + hGDim.l + hGDim.r)
      .attr("class", 'histogramExample')
      .attr("height", hGDim.h + hGDim.t + hGDim.b).append("g")
      .attr("transform", "translate(" + hGDim.l + "," + hGDim.t + ")");

    // create function for x-axis mapping.
    var x = d3.scale.ordinal().rangeRoundBands([0, hGDim.w], 0.1)
      .domain(fD.map(function(d) {
        return d[0];
      }));

    // Add x-axis to the histogram svg.
    hGsvg.append("g").attr("class", "x axis")
      .attr("transform", "translate(0," + hGDim.h + ")")
      .call(d3.svg.axis().scale(x).orient("bottom"));

    // Create function for y-axis map.
    var y = d3.scale.linear().range([hGDim.h, 0])
      .domain([0, d3.max(fD, function(d) {
        return d[1];
      })]);

    // Create bars for histogram to contain rectangles and freq labels.
    var bars = hGsvg.selectAll(".bar").data(fD).enter()
      .append("g").attr("class", "bar");

    //create the rectangles.
    bars.append("rect")
      .attr("x", function(d) {
        return x(d[0]);
      })
      .attr("y", function(d) {
        return y(d[1]);
      })
      .attr("width", x.rangeBand())
      .attr("height", function(d) {
        return hGDim.h - y(d[1]);
      })
      .attr('fill', barColor)
      .on("click", mouseover) // mouseover is defined below.
      // mouseout is defined below.

    //Create the frequency labels above the rectangles.
    bars.append("text").text(function(d) {
        return d3.format(",")(d[1])
      })
      .attr("x", function(d) {
        return x(d[0]) + x.rangeBand() / 2;
      })
      .attr("y", function(d) {
        return y(d[1]) - 5;
      })
      .attr("text-anchor", "middle");

    function mouseover(d) { // utility function to be called on mouseover.
      // filter for selected state.
      $('.pieChart1').remove();
      $('.legend1').remove();
      
      $('#firstPieChart').delay(1000).show();
      


      var st = fData.filter(function(s) {
        
          return s.State == d[0];
        })[0],
        nD = d3.keys(st.freq).map(function(s) {
          
          return {
            type: s,
            freq: st.freq[s]
          };
        });
        
        console.log('st',st)
        console.log('nd',nD)
        self.yearSelected = st.State
        var kD=[]
        kD[0]=nD[2];
        kD[1]=nD[0];
        kD[2]=nD[1]


      // call update functions of pie-chart and legend.  
      
       if(self.yearSelected==2017){
console.log(self.yearSelected)
      pC.update(nD, st);      
      leg.update(nD, st);
       }else{
         console.log(self.yearSelected)
      pC.update(kD, st);      
      leg.update(kD, st);
       }
    }
    

    function mouseout(d) { // utility function to be called on mouseout.
      // reset the pie-chart and legend.    
      pC.update(tF);
      leg.update(tF);
    }

    // create function to update the bars. This will be used by pie-chart.
    hG.update = function(nD, color) {
      // update the domain of the y-axis map to reflect change in frequencies.
      y.domain([0, d3.max(nD, function(d) {
        return d[1];
      })]);

      // Attach the new data to the bars.
      var bars = hGsvg.selectAll(".bar").data(nD);

      // transition the height and color of rectangles.
      bars.select("rect").transition().duration(2000)
        .attr("y", function(d) {
          return y(d[1]);
        })
        .attr("height", function(d) {
          return hGDim.h - y(d[1]);
        })
        .attr("fill", color);

      // transition the frequency labels2ocation and change value.
      bars.select("text").transition().duration(2000)
        .text(function(d) {
          return d3.format(",")(d[1])
        })
        .attr("y", function(d) {
          return y(d[1]) - 5;
        });
    }
    return hG;
  }

  // Function to handle pieChart.

  self.pieChart = function(pD) {
    var pC = {},
      pieDim = {
        w: 230,
        h: 230
      };
    pieDim.r = Math.min(pieDim.w, pieDim.h) / 2;

    // create svg for pie chart.
    pD.sort(dynamicSort("type"));
    console.log("$('.pieChart').length",$('.pieChart').length)
   if($('.pieChart').length==0){ 
     
     $(id).append('<div id="firstPieChart"></div>');
    var piesvg = d3.select('#firstPieChart').append("svg").attr('class', 'pieChart')
      .attr("width", pieDim.w).attr("height", pieDim.h).append("g")
      .attr("transform", "translate(" + pieDim.w / 2 + "," + pieDim.h / 2 + ")")
    // create function to draw the arcs of the pie slices.
    var arc = d3.svg.arc().outerRadius(pieDim.r - 10).innerRadius(0);

    // create a function to compute the pie slice angles.
    var pie = d3.layout.pie().sort(null).value(function(d) {
      return d.freq;
    });

    // Draw the pie slices.
    piesvg.selectAll("path").data(pie(pD)).enter().append("path").attr("d", arc)
      .each(function(d) {
        this._current = d;
      }).on("click", function(d){ 
        
        console.log(d.data.type)
        self.secondpie(d)
    })
      .style("fill", function(d) {
        
        
        return segColor(d.data.type);
      });
    // create function to update pie-chart. This will be used by histogram.
    pC.update = function(nD) {
        piesvg.selectAll("path").data(pie(nD)).transition().duration(500)
          .attrTween("d", arcTween);
      }
      // Utility function to be called on mouseover a pie slice.
    // how the intermediate paths should be drawn.
    function arcTween(a) {
      var i = d3.interpolate(this._current, a);
      this._current = i(0);
      return function(t) {
        return arc(i(t));
      };
    }
    return pC;
   }else if($('.pieChart').length==1){
     $('.pieChart1').remove()
     
     $(id).append('<div id="secondPieChart"></div>');
     var piesvg = d3.select('#secondPieChart').append("svg").attr('class', 'pieChart').attr('class', 'pieChart1')
      .attr("width", pieDim.w).attr("height", pieDim.h).append("g")
      .attr("transform", "translate(" + pieDim.w / 2 + "," + pieDim.h / 2 + ")")
    // create function to draw the arcs of the pie slices.
    var arc = d3.svg.arc().outerRadius(pieDim.r - 10).innerRadius(0);

    // create a function to compute the pie slice angles.
    var pie = d3.layout.pie().sort(null).value(function(d) {
      return d.freq;
    });

    // Draw the pie slices.
    piesvg.selectAll("path").data(pie(pD)).enter().append("path").attr("d", arc)
      .each(function(d) {
        this._current = d;
      })
      .style("fill", function(d) {
        return segColor(d.data.type);
      })


    // create function to update pie-chart. This will be used by histogram.
    pC.update = function(nD) {
        piesvg.selectAll("path").data(pie(nD)).transition().duration(500)
          .attrTween("d", arcTween);
      }
      // Utility function to be called on mouseover a pie slice.
    // how the intermediate paths should be drawn.
    function arcTween(a) {
      var i = d3.interpolate(this._current, a);
      this._current = i(0);
      return function(t) {
        return arc(i(t));
      };
    }
    return pC;
   } else{

   }
    
  }

  // function to handle legend.
  
  self.legend = function(lD, hh) {
    
    if($('.legend').length==0){
      var leg = {};
    // create table for legend.
   
  lD.sort(dynamicSort("type"));
    var legend = d3.select('#firstPieChart').append("table").attr('class', 'legend').append('tr').append('td').attr('colspan', '4').append('p').attr('text-align', 'center').attr("class", 'legendFreq').text('Total');
    // create one row per segment.
    var tr = legend.append("tbody").selectAll("tr").data(lD).enter().append("tr");
    // create the first column for each segment.
    tr.append("td").append("svg").attr("width", '15').attr("height", '15').append("rect")
      .attr("width", '15').attr("height", '15')
      .attr("fill", function(d) {
        
        return segColor(d.type);
      });
    // create the second column for each segment.
    tr.append("td").text(function(d) {
      return d.type;
    });
    // create the third column for each segment.
    tr.append("td").attr("class", 'legendFreq')
      .text(function(d) {
        return d3.format(",")(d.freq);
      });
    // create the fourth column for each segment.
    tr.append("td").attr("class", 'legendPerc')
      .text(function(d) {
        return getLegend(d, lD);
      });

    // Utility function to be used to update the legend.
    leg.update = function(nD, stmu) {

      // update the data attached to the row elements.
      var l = legend.select("tbody").selectAll("tr").data(nD);

      // update the frequencies.
      l.select('.legenYear').text(stmu.State)
      l.select(".legendFreq").text(function(d) {
        return d3.format(",")(d.freq);
      });

      // update the percentage column.
      l.select(".legendPerc").text(function(d) {
        return getLegend(d, nD);
      });
    }

    function getLegend(d, aD) { // Utility function to compute percentage.
      return d3.format("%")(d.freq / d3.sum(aD.map(function(v) {
        return v.freq;
      })));
    }

    return leg;
    }
    else if($('.legend').length==1){
      $('.legend1').remove()
      var leg = {};
    // create table for legend.
    
    var legend = d3.select('#secondPieChart').append("table").attr('class', 'legend').attr('class', 'legend1').append('tr').append('td').attr('colspan', '4').append('p').attr('text-align', 'center').attr("class", 'legendFreq').text('Total');
    // create one row per segment.
    var tr = legend.append("tbody").selectAll("tr").data(lD).enter().append("tr");
    // create the first column for each segment.
    tr.append("td").append("svg").attr("width", '15').attr("height", '15').append("rect")
      .attr("width", '15').attr("height", '15')
      .attr("fill", function(d) {
        return segColor(d.type);
      });
    // create the second column for each segment.
    tr.append("td").text(function(d) {
      return d.type;
    });
    // create the third column for each segment.
    tr.append("td").attr("class", 'legendFreq')
      .text(function(d) {
        return d3.format(",")(d.freq);
      });
    // create the fourth column for each segment.
    tr.append("td").attr("class", 'legendPerc')
      .text(function(d) {
        return getLegend(d, lD);
      });

    // Utility function to be used to update the legend.
    leg.update = function(nD, stmu) {

      // update the data attached to the row elements.
      var l = legend.select("tbody").selectAll("tr").data(nD);

      // update the frequencies.
      l.select('.legenYear').text(stmu.State)
      l.select(".legendFreq").text(function(d) {
        return d3.format(",")(d.freq);
      });

      // update the percentage column.
      l.select(".legendPerc").text(function(d) {
        return getLegend(d, nD);
      });
    }

    function getLegend(d, aD) { 
      // Utility function to compute percentage.
      return d3.format("%")(d.freq / d3.sum(aD.map(function(v) {
        return v.freq;
      })));
    }

    return leg;
    }
    else{

    }
    
  }

  // Calculate total frequency by segment for all state.

  var tF = ['lab','experiment','generic' ].map(function(d) {
    return {
      type: d,
      freq: d3.sum(fData.map(function(t) {
               
          
        return t.freq[d];
      }))
    };
  });

  // Calculate total frequency by state for all segment.

  var sF = fData.map(function(d) {
        
    return [d.State, d.total];
  });

  var hG = histoGram(sF) // create the histogram.
    // create the pie-chart.
  pC = self.pieChart(tF)

  leg = self.legend(tF, sF);

  $('#firstPieChart').hide();
 // $('.histogramExample').hide();
  //$('table').hide();
  

}
#+END_SRC

** Create legend
   It create legends in the form of the tables which shows feedback counts in numbers as well as in percentage for both the pie charts.
#+NAME: create-legend
#+BEGIN_SRC html

var totalYear = []

$.ajax({ // Ajax call for URL
  method: 'GET',
  url: "http://feedback-analytics.vlabs.ac.in/vlabs/feedback/_search?size=10000", // Keep URL here
  type: 'json' // define type here
}).done(function(data /*this is the data or response*/ ) { 
  $('#fillgauge1').animate({
        

      }, 1000);
      
      
var piechart1 = dashboardFunction(data);
  // var difference = maxHeight / max // getting the difference to fit the original data onto new coordinate systems

  dashboard('#dashboard', piechart1);

});
self.secondpie = function(Selectedversions){
  

  $.ajax({ // Ajax call for URL
  method: 'GET',
  url: "http://feedback-analytics.vlabs.ac.in/vlabs/feedback/_search?size=10000", // Keep URL here
  type: 'json' // define type here
}).done(function(data /*this is the data or response*/ ) {
  var piechart2 = dashboardFunction(data,Selectedversions.data.type);
  
  if(Selectedversions.data.type == "generic"){
/*
Selectedversions=="generic-feedback-v2.0" || Selectedversions=="virtual-labs-feedback-v1.0"
OL = Open-Edx labs feedback v2.0 (onclick of lab)
NOL = generic labs feedback v2.0 (onclick of lab)

*/
var tF = ['generic_feedback_v2_0','virtual_labs_feedback_v1_0'].map(function(d) {
  
    return {
      type: d,
      freq: d3.sum(piechart2.map(function(t) {          
          if(t.State==self.yearSelected){
            return t.freq[d];
          }else{
            return 0
          }
          
        
      }))
    };
  });
}else if(Selectedversions.data.type == "experiment"){/*

OL = Open-Edx labs feedback v2.0 (onclick of lab)
NOL = generic labs feedback v2.0 (onclick of lab)

*/
var tF = ['generic_exp_feedback_v2_0', 'open_edx_virtual_labs_v2_0_for_experiment'].map(function(d) {
  
    return {
      type: d,
      freq: d3.sum(piechart2.map(function(t) {
        
          if(t.State==self.yearSelected){
            return t.freq[d];
          }else{
            return 0
          }        
        
      }))
    };
  });
} else if(Selectedversions.data.type == "lab"){
/*
Selectedversions=="generic-lab-feedback-v2.0" || Selectedversions=="open-edx-virtual-labs-v2.0_for_lab"
OL = Open-Edx labs feedback v2.0 (onclick of lab)
NOL = generic labs feedback v2.0 (onclick of lab)

*/

var tF = ['generic_lab_feedback_v2_0', 'open_edx_virtual_labs_v2_0_for_lab'].map(function(d) {
  
    return {
      type: d,
      freq: d3.sum(piechart2.map(function(t) {
          
         if(t.State==self.yearSelected){
            return t.freq[d];
          }else{
            return 0
          }
      }))
    };
  });
} else{

}
piechart2.forEach(function(d) {
  console.log(d)
  

    if (d.freq.lab == 0 || !d.freq.lab) {
      d.freq.lab = 0
    }
    if (d.freq.experiment == 0 || !d.freq.experiment) {
      d.freq.experiment = 0
    }
    if (d.freq.generic == 0 || !d.freq.generic) {
      d.freq.generic = 0
    }
    
   

    if (d.freq.virtual_labs_feedback_v1_0 == 0 || !d.freq.virtual_labs_feedback_v1_0) {
      d.freq.virtual_labs_feedback_v1_0 = 0
    }
    if (d.freq.open_edx_virtual_labs_v2_0_for_lab == 0 || !d.freq.open_edx_virtual_labs_v2_0_for_lab) {
      d.freq.open_edx_virtual_labs_v2_0_for_lab = 0
    }
    if (d.freq.generic_feedback_v2_0 == 0 || !d.freq.generic_feedback_v2_0) {
      d.freq.generic_feedback_v2_0 = 0
    }
    
    if (d.freq.open_edx_virtual_labs_v2_0_for_experiment == 0 || !d.freq.open_edx_virtual_labs_v2_0_for_experiment) {
      d.freq.open_edx_virtual_labs_v2_0_for_experiment = 0
    }
    if (d.freq.generic_exp_feedback_v2_0 == 0 || !d.freq.generic_exp_feedback_v2_0) {
      d.freq.generic_exp_feedback_v2_0 = 0
    }
    if (d.freq.generic_lab_feedback_v2_0 == 0 || !d.freq.generic_lab_feedback_v2_0) {
      d.freq.generic_lab_feedback_v2_0 = 0
    }
    
 /*
r = str.replace(/virtual-labs-feedback-v1.0/g, 'virtual_labs_feedback_v1_0');
  str = str.replace(/open-edx-virtual-labs-v2.0_for_lab/g, 'open_edx_virtual_labs_v2_0_for_lab');
  str = str.replace(/generic-feedback-v2.0/g, 'generic_feedback_v2_0');
  str = str.replace(/open-edx-virtual-labs-v2.0_for_experiment/g, 'open_edx_virtual_labs_v2_0_for_experiment');
  str = str.replace(/generic-exp-feedback-v2.0/g, 'generic_exp_feedback_v2_0');
  str = str.replace(/generic-lab-feedback-v2.0/g, 'generic_lab_feedback_v2_0');

*/   
    d.total = parseInt(d.freq.generic + d.freq.experiment + d.freq.lab + d.freq.virtual_labs_feedback_v1_0 + d.freq.open_edx_virtual_labs_v2_0_for_lab + d.freq.generic_feedback_v2_0 + d.freq.open_edx_virtual_labs_v2_0_for_experiment + d.freq.generic_exp_feedback_v2_0 + d.freq.generic_lab_feedback_v2_0);

  });
 var sF = piechart2.map(function(d) {
    
    return [d.State, d.total];
  });
  
self.pieChart(tF)
self.legend(tF, sF)
})

}
this.dynamicSort=function(property) {
    var sortOrder = 1;
    if(property[0] === "-") {
        sortOrder = -1;
        property = property.substr(1);
    }
    return function (a,b) {
        var result = (a[property] < b[property]) ? -1 : (a[property] > b[property]) ? 1 : 0;
        return result * sortOrder;
    }
}
#+END_SRC

** Dashboard function
   It control function of bar graph and two pie charts so that it works dynamically.
#+NAME: dashboard-function
#+BEGIN_SRC html

function dashboardFunction(dataset,typeofPie){
  
  var i = 0
  var Selectedversions;

  var freq = {}
  var dict = []
  var dict2 = {}
  var freqDataTemp = []
  dataSet = dataset // meh !! for no reason.. You can actually troubleshoot from console using this variable => scope: global

  var t = 0
  var counter = 0;
  for (var index1 = 0; index1 < dataSet["hits"]["hits"].length; index1++) { //  iterates through first lebel
    var year;
    if (dataSet.hits.hits[index1]._source.version) {
      if (typeof(dataSet["hits"]["hits"][index1]["_source"]["date"]) != "undefined") { // filters the undefined type to prevent stopping of execution
        year = dataSet["hits"]["hits"][index1]["_source"]["date"].split("-")[2] // extracting the year from the given date.
      }
      // if(typeof(dataSet["hits"]["hits"][index1]["_source"]["responses"]) != "undefined")
      //  for(var index2 = 0; index2dataset.max() * gap < dataSet["hits"]["hits"][index1]["_source"]["responses"].length;index2++){ // this is the secondary level for accessing the responses and questions.
      /*
       this piece of code will maintain a dictionsary with year as key and number of repetetions as values.
       In if condition you arew +checking whether the year is present or not. If it is true, then we have to update the value of that year by incrementing by 1(that's done  else condition)
       if year is a new entry then just intialize with 1.
      */
      if (!(year in dict)) {
        dict[counter] = parseInt(year)
        counter++
      } else {


      }

      // console.log(dataSet["hits"]["hits"][index1]["_source"]["date"])//["responses"][index2]["answers"][0]["name"])
      //  }// end of innner for loop
    } // ennd of outer for loop

  }
  // to get unique array
  dict = dict.filter(function(x, i, a) {
    return a.indexOf(x) == i;
  });
  // to sort an array in year wise
  dict.sort(function(a, b) {
    return a - b
  });
  
  for (var curryear = 0; curryear < dict.length; curryear++) {
    dict2 = {}
    var secondPieObject = {};
    for (var index1 = 0; index1 < dataSet["hits"]["hits"].length; index1++) { //  iterates through first lebel
      var year;
      if (dataSet.hits.hits[index1]._source.version) {

        if (typeof(dataSet["hits"]["hits"][index1]["_source"]["date"]) != "undefined") { // filters the undefined type to prevent stopping of execution
          year = dataSet["hits"]["hits"][index1]["_source"]["date"].split("-")[2] // extracting the year from the given date.
        }
        // console.log(dataSet["hits"]["hits"][index1]["_source"]["date"])//["responses"][index2]["answers"][0]["name"])
        //  }// end of innner for loop
      } // ennd of outer for loop
      if (typeof(dataSet["hits"]["hits"][index1]["_source"]["date"]) != "undefined" && dataSet["hits"]["hits"][index1]["_source"]["date"].split("-")[2] == dict[curryear]) {


        if (typeof(dataSet["hits"]["hits"][index1]["_source"]["date"]) != "undefined") { // filters the undefined type to prevent stopping of execution
          Selectedversions = dataSet["hits"]["hits"][index1]["_source"]["version"] // extracting the year from the given date.
        }
if(typeofPie!=='' && typeofPie){

  if(typeofPie == 'lab'  && (Selectedversions =='open-edx-virtual-labs-v2.0_for_lab' || Selectedversions == 'generic-lab-feedback-v2.0' )) {
    if (!(Selectedversions in secondPieObject)) {
          secondPieObject[Selectedversions] = 1
        } else {
          var temp = secondPieObject[Selectedversions]
          temp = temp + 1
          console.log('secondPieObject['+Selectedversions+']',secondPieObject[Selectedversions])
          secondPieObject[Selectedversions] = temp
          
        }
  } else if(typeofPie == 'generic' && (Selectedversions == 'generic-feedback-v2.0' || Selectedversions=="virtual-labs-feedback-v1.0")){
    if (!(Selectedversions in secondPieObject)) {
          secondPieObject[Selectedversions] = 1
        } else {
          var temp = secondPieObject[Selectedversions]
          temp = temp + 1
          
          secondPieObject[Selectedversions] = temp;
          console.log('secondPieObject['+Selectedversions+']',secondPieObject[Selectedversions])
        }

  } else if(typeofPie == 'experiment' && (Selectedversions == 'open-edx-virtual-labs-v2.0_for_experiment' || Selectedversions == 'generic-exp-feedback-v2.0')){
    if (!(Selectedversions in secondPieObject)) {
          secondPieObject[Selectedversions] = 1
        } else {
          var temp = secondPieObject[Selectedversions]
          temp = temp + 1
          console.log('secondPieObject['+Selectedversions+']',secondPieObject[Selectedversions])
          
          secondPieObject[Selectedversions] = temp
        }

  }

}
else{
if(Selectedversions=="generic-exp-feedback-v2.0" || Selectedversions=="open-edx-virtual-labs-v2.0_for_experiment"){

        if (!('experiment' in dict2)) {
          dict2['experiment'] = 1
        } else {
          var temp = dict2['experiment']
          temp = temp + 1
          
          dict2['experiment'] = temp
        }
}
 if(Selectedversions=="generic-feedback-v2.0" || Selectedversions=="virtual-labs-feedback-v1.0"){

        if (!('generic' in dict2)) {
          dict2['generic'] = 1
        } else {
          var temp = dict2['generic']
          temp = temp + 1
          
          dict2['generic'] = temp
        }
}
if(Selectedversions=="generic-lab-feedback-v2.0" || Selectedversions=="open-edx-virtual-labs-v2.0_for_lab"){

        if (!('lab' in dict2)) {
          dict2['lab'] = 1
        } else {
          var temp = dict2['lab']
          temp = temp + 1
          
          dict2['lab'] = temp
        }
}


}//else
      }

    }



var freq={}

if(typeofPie!=='' && typeofPie){
 freq = JSON.parse(JSON.stringify(secondPieObject))
}else{
 freq = JSON.parse(JSON.stringify(dict2))
}
   

    
    freqDataTemp[t] = {
      State: '' + dict[curryear],
      freq
    }
    t++
  
  }


  var str = JSON.stringify(freqDataTemp);
  str = str.replace(/virtual-labs-feedback-v1.0/g, 'virtual_labs_feedback_v1_0');
  str = str.replace(/open-edx-virtual-labs-v2.0_for_lab/g, 'open_edx_virtual_labs_v2_0_for_lab');
  str = str.replace(/generic-feedback-v2.0/g, 'generic_feedback_v2_0');
  str = str.replace(/open-edx-virtual-labs-v2.0_for_experiment/g, 'open_edx_virtual_labs_v2_0_for_experiment');
  str = str.replace(/generic-exp-feedback-v2.0/g, 'generic_exp_feedback_v2_0');
  str = str.replace(/generic-lab-feedback-v2.0/g, 'generic_lab_feedback_v2_0');

  i = 0

  freqDataTemp = JSON.parse(str);
  
  var max = -1
    //var maxHeight = canvas.attr("height") / 2  // defines the maximum height of you grpah you are trying to plot and fit the original data.
  for (var key in dict) { // loop to find the maximum number to define the scale
    if (max < dict[key]) max = dict[key]
  }
 return freqDataTemp;
}

#+END_SRC

** CSS
   It contains css for for complete service which makes the service responsive.
#+NAME: style-sheets
#+BEGIN_SRC html 
body{
    width:100%;
    margin:0px auto;
}
path {  stroke: #fff; }
path:hover {  opacity:0.9; }
rect:hover {  fill:#ee5c42; }
.axis {  font: 10px sans-serif; }
.legend tr{    border-bottom:1px solid grey; }
.legend tr:first-child{    border-top:1px solid grey; }
.legend1 tr{    border-bottom:1px solid grey; }
.legend1 tr:first-child{    border-top:1px solid grey; }
.axis path,
.axis line {
  fill: none;
  stroke: #000;
  shape-rendering: crispEdges;
}
#firstPieChart,#secondPieChart,#barChartExample
{
  display: inline-block
}
#barChartExample{
  margin-left: 3%;
  border: 1px solid #000;
  width: 29%;
  box-shadow: 2px 2px 9px #8e8e6f;
  border-radius: 7px;
}
#firstPieChart,#secondPieChart{
  margin-top: 10px;
  box-shadow: 2px 2px 9px #8e8e6f;
  border-radius: 7px;
  border: 1px solid #000;
  margin-left: 2%;
}
#firstPieChart{
   width: 35%;
  padding: 0px 10px 0 10px;
  }
#secondPieChart{ width: 56%;
  padding: 0px 10px 0 10px;
    }
#fillgaugeContainer{
  box-shadow: 2px 2px 9px #8e8e6f;
  border-radius: 7px;
  border: 1px solid #000;
  margin-left: 13%;
  display: inline-block;
  padding: 66px;
  padding-bottom: 1px;
  width: 332px;
  margin-bottom: 13px;
}
.x.axis path {  display: none; }
.legend{
    display: inline-block;
    border-collapse: collapse;
    border-spacing: 0px;
    margin-left: 1%;
    margin-bottom: 4%;
}
.legend td{
    padding:4px 5px;
    vertical-align:bottom;
}
.legend1 td{
    padding:4px 5px;
    vertical-align:bottom;
}
.histogramExample{
    display: inline-block;
}
.pieChart{
   margin-left: -2%;
}
.pieChart1{
    margin-left: 0%;
}
.legend1{
  display: inline-block;
    margin-bottom: 6%;
    border-collapse: collapse;
    border-spacing: 0px;
}
.liquidFillGaugeText {
    font-family: Helvetica;
    font-weight: bold;
}
.main{
    height : 100%;
    width : 100%;
}
.bottom{
    height : 60%;
    width : 100%;
    margin-top:2%;
}
.histogramExample{
  margin-left: 8%
}
#fillgauge1{
  display: inline-block;
}

/* ----------- 950px - 1400px ----------- */
@media screen
  and (min-width: 900px)
  and (max-width: 1400px){

#fillgaugeContainer{
  margin-left: 16%;
  width: 20%;
  padding-left: 4%;
  margin-bottom: 1%;
}
.histogramExample {
    margin-left: 16%;
    height:300px;
}
#barChartExample{
  margin-left: 3%;
  width: 32%;
  margin-bottom: 2%;
}
.pieChart {
    margin-left: -3%;
}
.pieChart1 {
    margin-left: 1%;
}
}

/* ----------- 1400px + ----------- */
@media screen 
  and (min-width: 1401px){

#fillgaugeContainer{
  margin-left: 22%;
  width: 18%;
  padding-left: 7%;
  margin-bottom: 2%;
}
.histogramExample {
    margin-left: 18%;
    height:370px;
}
#barChartExample{
  margin-bottom: 2%;
}
.pieChart {
    margin-left: 12%;
}
.pieChart1 {
    margin-left: 14%;
}
#fillgauge1{
  margin-bottom: 18%;
}
#firstPieChart, #secondPieChart{
  padding-top: 2%;
  padding-bottom: 2%;
}
}

#+END_SRC

* Tangle 
** sources
*** Javascript
#+BEGIN_SRC javascript :tangle static/js/chart_display.js :eval no :noweb yes 
<<liquidfillgauge-defaultsettings>>
<<load-liquidfillgauge>>
<<main-dashboard>>
<<create-legend>>
<<dashboard-function>>

#+END_SRC
*** HTML
#+BEGIN_SRC html :tangle templates/index.html :eval no :noweb yes
<<main-html>>
#+END_SRC

*** CSS
#+BEGIN_SRC css :tangle static/css/tab.css :eval no :noweb yes 
<<style-sheets>>
#+END_SRC
